# 			      算法

### 一、基础概念

**算法的特性**

- 输入输出

  一个算法可以有0个或者多个输入 以表示运算对象的初始化情况 0输入代表算法本身定出了初始条件；一个算法有一个或多个输出，以反映对输入数据加工后的结果，没有输出的算法是毫无意义的。

- 有穷性

  算法必须在执行有限步骤之后停止执行

- 确定性

  算法每一步骤必须有确切的定义

- 可行性

  算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）

**算法的要求**

- 正确性

   指的是算法至少应该有输入,输出和加工处理无歧义性，能正确反映问题的需求,能够得到问题的正确答案。确定性大体分为四个层次:

  1. 算法程序无语法错误;
  2. 算法程序对于合法的输入产生满足要求的输出;
  3. 对于非法输入能够产生满足规格的说明;
  4. 算法程序对于故意刁难的测试输入都有满足要求的输出结果。 

- 可读性

  程序便于阅读,理解交流

- 健壮性

  当输入数据不合法时,算法也能作出相关处理，而不是产生异常,崩溃或者莫名其妙的结果。 

- 时间效率高和存储量低

**算法效率的度量方法**

1. 事后统计方法：主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但这种方法有很大缺陷，一般不予采纳。
2. 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。
3. 一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于以下因素：
   1. 算法采用的策略，方法；（算法好坏的根本）
   2. 编译产生的代码质量；（由软件来支持）
   3. 问题的输入规模；（由数据决定）
   4. 机器执行指令的速度。（看硬件的性能）

**算法的时间复杂度**

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随n的变化情况并确定 T(n) 的数量级。算法的时间复杂度（算法的时间量度）记作 T(n) = O（f(n)）。表示随着问题规模n的增长，算法执行的时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。其中 f(n) 是问题规模n的某个函数。

求解算法的时间复杂度的具体步骤是：

1. 找出算法中的基本语句

   算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

2. 计算基本语句的执行次数的数量级

   只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

3. 用大Ο记号表示算法的时间性能

   将基本语句执行次数的数量级放入大Ο记号中

大O阶方法

（1）用常数1取代运行时间中的所有加法常数。

（2）在修改后的运行次数函数中，只保留最高阶项。

（3）如果最高阶项存在且不为1，则去除与这个项相乘的常数，得到的结果就是大O阶，即时间复杂度。

简单的说，就是保留求出次数的最高次幂，并且把系数去掉。  如
$$
T(n)=n^2+n+1 =O(n^2)
$$
常见的时间复杂度所消耗时间的大小
$$
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$
**空间复杂度**

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，这种算法是节省存储的算法；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元。

如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。 

**算法的好坏使用时间复杂度与空间复杂度来衡量**

### 二、排序

![image-20210804185942841](https://gitee.com/zhengqianhua0314/image-store/raw/master/image-20210804185942841.png)

**术语解释**

1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。

2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。

3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。

4、非原地排序：需要利用额外的数组来辅助排序。

5、时间复杂度：一个算法执行所消耗的时间。

6、空间复杂度：运行完一个算法所需的内存大小。

![image-20210804185517667](https://gitee.com/zhengqianhua0314/image-store/raw/master/image-20210804185517667.png)

#### 1、选择排序(Selection Sort)

时间复杂度：


$$
O(n^2)
$$
空间复杂度：O(1)   

非稳定性

找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。

![img](https://gitee.com/zhengqianhua0314/image-store/raw/master/2463290-73ce127832eee7d8.gif)

```java
public class SelectionSort {
/*
1，找到数组中最小的那个元素，
2，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。
3，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。
4，如此往复，直到将整个数组排序。这种方法我们称之为选择排序
 */
    public static void main(String[] args) {

        int[] arr = {5,2,7,3,9,4,6,8,1};

        for (int i = 0; i < arr.length -1; i++) {
            int minPos = i;

            for (int j = i + 1; j < arr.length; j++) {

                if(arr[minPos] > arr[j] ){
                    minPos = j;
                }
            }
            //交换
            int temp = arr[i];
            arr[i] = arr[minPos];
            arr[minPos] = temp;
        }

        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```

#### 2、插入排序(Insertion Sort)

时间复杂度：


$$
O(n^2)
$$
空间复杂度：O(1)   

稳定排序

**样本小且基本有序的时候效率高**

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

1. 从数组第2个元素开始抽取元素。
2. 把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。
3. 继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入

![img](https://gitee.com/zhengqianhua0314/image-store/raw/master/793314-20190620120720528-714028356.gif)

```java
/**
 * @Description 插入排序
 * @Author Hua
 * @Date 2021/8/5
 * @Version 1.0
 **/
public class InsertionSort {

    public static void main(String[] args) {

        int[] arr = {2,5,8,6,9,7,4,3,52,18};

        for (int i = 1; i < arr.length; i++) {
            //
            int current = arr[i];
            int preIndex = i -1 ;
            while(preIndex >= 0 && current < arr[preIndex]){
                arr[preIndex+1] = arr[preIndex];
                preIndex--;
            }
            arr[preIndex+1] = current;
        }

        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

}
```

#### 3、冒泡排序(Bubble Sort)

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。

时间复杂度：


$$
O(n^2)
$$
空间复杂度：O(1)   

稳定排序



![img](https://gitee.com/zhengqianhua0314/image-store/raw/master/793314-20190620121302237-866700406.gif)

```java
/**
 * @Description 冒泡排序
 * @Author Hua
 * @Date 2021/8/5
 * @Version 1.0
 **/
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {2,5,8,6,9,7,4,3,52,18};

        for (int k = arr.length; k > 0; k--) {
            for (int i = 0; i < k - 1; i++) {
                if (arr[i] > arr[i+1]) {
                    int temp = arr[i];
                    arr[i] = arr[i+1];
                    arr[i+1] = temp;
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```

#### 4、希尔排序(Shell Sort)

希尔排序可以说是**插入排序**的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。

希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。

希尔排序的思想是采用**插入排序**的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。



![image-20210805200231072](https://gitee.com/zhengqianhua0314/image-store/raw/master/image-20210805200231072.png)

```java
/**
 * @Description 希尔排序
 * @Author Hua
 * @Date 2021/8/5
 * @Version 1.0
 **/
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {2,5,8,6,9,7,4,3,52,18};
        int length = arr.length;
        int gap = length/2;
        
        while (gap > 0){
            for(int i = gap;i < length;i++){
                int current = arr[i];
                int preIndex = i - gap;
                while (preIndex > 0 && current < arr[preIndex]){
                    arr[preIndex+gap] = arr[preIndex];
                    preIndex -= gap;
                }
                arr[preIndex+gap] = current;
            }
            gap /=2;
        }

        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```

